<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<appendix xmlns="http://docbook.org/ns/docbook" 
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"  xml:id="appendix.technical">
    <title>Technical information</title>
    <para>
        <note>
            <para>This section is only meant for developers and contains brief information on the
                internals of the software.</para>
        </note>
    </para>
    <section>
        <title>Documentation format</title>
        <para>The documentation is written entirely using the Docbook5 <acronym>XML</acronym> schema and transformed
            into the various output formats using the official XSL style sheets (currently version
            1.78.1) with a thin customization layer (in <filename>xslt_stylesheets/</filename>). The
            transformation is done using <command>xsltproc</command> and
                Apache-<command>fop</command> controlled with a standard makefile. All output is
            written into the appropriate format directory in <filename>out/</filename>. The manual
            makes use of <literal>XInclude</literal> schema to split the manual in separate files
            for ease of maintenance. The HTML rendering is further customized with a CSS style sheet
            to make it a bit more readable and nice. In order to create a text rendering of the
            manual the HTML version is converted to text using the ASCII-web browser
                "<command>links</command>".</para>
        <para>The included bootstrap scripts (see <xref xlink:href="#section.build-system"/>) will
            setup a complete working DocBook5 environment. Since <acronym>XML</acronym> is quite
            verbose it is also recommended that editing is done in a <acronym>XML</acronym> aware
            editor to make text editing less tedious.</para>
    </section>
    <section>
        <title>The database schema</title>
        <para>The database contains three tables:</para>
        <para>
            <itemizedlist>
                <listitem>
                    <para><literal>tbl_track</literal>, stores all the information received back
                        from the device events</para>
                </listitem>
                <listitem>
                    <para><literal>tbl_info</literal>, stores meta information about the DB and
                        application itself</para>
                </listitem>
                <listitem>
                    <para><literal>tbl_device_nick</literal>, stores all defined nick names for
                        devices</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>The daemon has built in functionality to export the track database into both its
            internal <acronym>XML</acronym> format (see <xref
                xlink:href="#section.internal-export-format"/>) and standard GPX (<emphasis
                role="italic">Gps Exchange format</emphasis>) and KML (<emphasis role="italic"
                >Google Maps</emphasis>) as well CSV (<emphasis role="italic">Comma separated
                values</emphasis>). This is further described in <xref
                xlink:href="#section.exporting-db"/>.</para>
        <figure>
            <title>DB Schema</title>
            <programlisting><xi:include href="./dbdoc/db_schema.sql" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </figure>
        
    </section>
    <section  xml:id="section.internal-export-format">
        <title>The internal <acronym>XML</acronym> export format
            grammar</title>
        <para>The <acronym>XML</acronym> export is a fairly straightforward export in
                <acronym>XML</acronym> format where each row in the database corresponds to a single
                <literal>event_export</literal>. The reason to create a proprietary format os that
            neither <acronym>GPX</acronym> nor <acronym>KML</acronym> format allows for the
            inclusion of device specific data as for example battery level or the status of the
            detach button. This is also exported in the CSV format but the author is partial to the
                <acronym>XML</acronym> format since it makes post processing so much easier (once
            you know <acronym>XSLT</acronym> to do transformations).</para>
        <para>The grammar below is written using the <acronym>RNG</acronym> (Relax New Grammar)
            schema. The corresponding graphical representation is shown in <xref
                linkend="fig.export-rng-grammar"/></para>            
            <programlisting><xi:include href="dbdoc/export_db.rng" parse="text" 
                xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>                    
        <para>
            <figure xml:id="fig.export-rng-grammar">
                <title>RNG Grammar for <acronym>XML</acronym> Export format</title>
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata fileref="dbdoc/export_db-rng-grammar.png" scalefit="1"
                            width="70%" contentwidth="70%"/>
                    </imageobject>
                    <imageobject role="html">
                        <imagedata fileref="img/export_db-rng-grammar.png" scalefit="1"
                            contentwidth="700px"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
    </section>
    <section>
        <title>Configuring the daemon to generate a stack-trace</title>
        <para>It is possible to compile the daemon so that in the unlikely event of a program crash
            (or technically a <literal>SIGSEGV</literal>) a stack trace is generated. This is useful
            for a released program since it is unlikely that an end user will be running on a system
            which allows core dumps and in any he/she would not know what to do with it. In that
            case a stack trace is the best we can do since we might also asl the end user to mail
            that short file to us to give a rough indication of where the problem occurred.</para>
        <para>Automatic stack trace is generated in the event of a <literal>SIGSEGV</literal> when
            the compile is configured with</para>
        <para>
            <screen>./configure --enable-stacktrace</screen>
        </para>
        <para>If this is done then a stack trace will be written to
                "<filename>/tmp/g7ctrl_stack-&lt;timestamp>.crash</filename>" where
                <literal>timestamp</literal> is replaced by the current time when the event
            occurred. An example of such a stack trace is shown below</para>
        <para>
            <screen>signal 11 : "Segmentation fault" at 0x407191 accessing 0x2540be3ff (Reason: "Addressed not mapped")
HINT: Use "addr2line -e g7ctrl 0x407191" to find out which line is giving this condition.

Stack trace:
./src/g7ctrl(sigsegv_handler+0x163)[0x4074a3]
./src/g7ctrl(main+0x1d1)[0x407191]
./src/g7ctrl(main+0x1d1)[0x407191]
/lib64/libc.so.6(__libc_start_main+0xf5)[0x7f7171264a15]
./src/g7ctrl[0x407269]</screen>
        </para>
        <para>This is not a completely robust solution since there are cases where the stack trace
            will be incomplete or there is such a catastrophic memory overwrite that the stack is
            completely destroyed. However, in practice this will help find a common null-pointer
            problem or an uninitialized pointer. The walk back of the stack frames are done with the
            help of the gnulib <literal>backtrace()</literal> function. This also means that this
            functionality will not be available when compiling on non gnulib systems, such as
                <acronym>OSX</acronym>.</para>
        <para>By default stack traces are not enabled (nor is it enabled in the packaged
            distribution).</para>
        <para>To help pinpoint the location of the violation the system command
                <command>addr2line</command> is commonly used and the stack trace gives a hint on
            how to use that command to exactly pinpoint the line in the code that caused this issue.
                <emphasis role="bold">CAVEAT</emphasis>: For a completely destroyed stack this will
            not work since the stack frames may have been destroyed as. If such a problem is
            encountered a full core dump is needed for a post-mortem debugging session. How to
            enable a system core dump for misbehaving applications (or daemons) is system dependent
            and not further discussed here assuming that a developer knows how to enable
            this.</para>
    </section>
    <section>
        <title>Configuring for a simulated device</title>
        <para>In order to be able to run the daemon and its command without having to physically
            attach a device it is possible to compile a version of the daemon which simulates a
            connected device. To keep things simple in version 1.0.0 the simulated device will
            always return an error. In future version this simulation might be extended to return
            command specific "fake" data. A simulated build is configured with</para>
        <para><screen>./configure  --enable-simulate</screen></para>
        <para>This will allow running the daemon without any messages about a missing device and
            will allow device commands (even though the simulated device will behave as if it had an
            error)</para>
    </section>
    <section>
        <title>Protocol description</title>
        <para>The protocol is a plain text (<acronym>UTF8</acronym>) based command-response type
            protocol. The daemon will send different amount of information back depending on the
            actual command. However, the daemon guarantees that no reply shall ever exceed a buffer
            size of 10K. To indicate that the daemon has finished sending data back and is awaiting
            a new command the sequence "<literal>\r\n</literal>" ends the data. A client should
            therefore implement a reading loop similar to the following example
                <code>readwrite()</code></para>
        <para>
            <programlisting>#define LEN_10K (10*1024)
#define NUM_RETRIES 3
#define SOCK_DISCONNECTED -99

/**
 * Utility variant of the standard read() function which handles signal
 * interruption and connection reset in a graceful way. Basically it will
 * resume the read() operation when a temporary error has happened. 
 * 
 * @param sockd Socket descriptor
 * @param[out] buffer Buffer to hold the read string
 * @param buffLen Maximum length of the storage buffer
 * @return the number of bytes read, 0 on connection close/reset, otherwise
 * &lt; 0 indicates an error and errno is set.
 */
int
socket_read(const int sockd, void *buffer, const size_t buffLen) {
    int rc;
    while( TRUE ) {
        rc = read(sockd,buffer, buffLen);
        if( (-1 == rc) &amp;&amp; (EINTR == errno) ) {
            continue;        
        } else {
            break;
        }
    }
    return rc;
}


/**
 * Read a reply from a socket with a 5s timeout.
 * 
 * @param sock Socket to read from
 * @param buffer Buffer for reply
 * @param maxbufflen Maximum reply length
 * @param nread number of chars read
 * @return 0 on success, -3 timeout, -2 buffer to small for reply, -1 other error
 */
int
waitread(int sock, char *buffer, int maxbufflen, int *nread) {
    fd_set read_fdset;
    struct timeval timeout;

    FD_ZERO(&amp;read_fdset);
    FD_SET(sock, &amp;read_fdset);

    // 5s timeout
    timerclear(&amp;timeout);
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    int rc = select(sock + 1, &amp;read_fdset, NULL, NULL, &amp;timeout);
    if (0 == rc) {
        // Timeout
        *nread = 0;
        *buffer = '\0';
        return -3;
    } else if( rc &lt; 0 ) {
        return -1;
    } else {
        *nread = socket_read(sock, buffer, maxbufflen);
        if (*nread >= maxbufflen - 1) {
            // Reply is longer than we can receive
            *nread = 0;
            *buffer = '\0';
            return -2;
        } else if (*nread > 0 ) {
            buffer[*nread + 1] = '\0';
        } else {
            *buffer = '\0';
            return SOCK_DISCONNECTED;
        }
    }
    return 0;
}

/**
 * Read reply from readsock until a "\r\n" sequence is found. Write partial
 * replies to writesock as we go if writesock > 0
 * @param readsock Socket/fd to read from
 * @param writesock Socket/fd to write patyal replies from (if writesock == 1)
 * no replies will be written.
 * @param buffer Reply buffer (stores the complete reply)
 * @param maxbufflen Maximum reply buffer
 * @return  0 on success, -1 on failure, -2 on buffer too small to hold reply
 * -3 = connection reset
 */
int
readwrite(int readsock, int writesock, char *buffer, int maxbufflen) {

    char *pbuff = calloc(LEN_10K, sizeof (char));
    *buffer = '\0';
    int totlen = 0, rc = 0, nread = 0;
    int retries = NUM_RETRIES;
    while (totlen &lt; maxbufflen) {
        rc = waitread(readsock, pbuff, LEN_10K, &amp;nread);
        if (0 == rc) {
            retries = NUM_RETRIES;
            pbuff[nread] = '\0';

            if (totlen + nread &lt; maxbufflen) {
                strcat(buffer, pbuff);
                totlen += nread;
            } else {
                free(pbuff);
                return -2; // Buffer too small
            }

            // Current output from daemon is finished with a "\r\n" sequence but we 
            // don't want to include that in the output to the user
            if (nread >= 2 &amp;&amp; '\r' == pbuff[nread - 2] &amp;&amp; '\n' == pbuff[nread - 1]) {
                pbuff[nread - 2] = '\0';
                _writef(writesock, "%s", pbuff);
                break;
            } else if (writesock > 0) {
                // Write back a partial response
                _writef(writesock, "%s", pbuff);
            }

        } else if (-3 == rc) {
            // Try 3 times when we get a timeout
            retries--;
            if (retries &lt;= 0) {
                free(pbuff);
                return -1;
            }
        } else if ( rc &lt; 0 ) {
            free(pbuff);
            if( SOCK_DISCONNECTED == rc )
                return -3;
            else 
                return -1;
        }
    }

    buffer[maxbufflen - 1] = '\0';
    free(pbuff);
    return 0;
}
</programlisting>
        </para>
        <para>The code is also slightly complicated by the fact that some daemon commands takes a
            bit of time to perform and the daemon sends back progress information even before the
            finishing "<literal>\r\n</literal>". This means that we should handle (and possible show
            the user) this progress information. This is handled in the <code>readwrite()</code>
            function. using the descriptor <code>writesock</code>
        </para>
        <para>In case of timeout the above code will retry <code>NUM_RETRIES</code> before giving
            up.</para>
    </section>
    
    <section>
        <title>Internal architecture</title>
        <para>The software is built pretty much as a standard multi-threaded socket server with
            the possibility to detach from the controlling terminal. It can arbitrate between
            multiple clients and can handle multiple incoming tracker connections.</para>
        <para>It can however not at present handle multiple USB connected devices at one time.
        This is though not big issue since it would be awkward for the end user as well as
        he or her would have to augment each command to specify which of the connected devices
        the command is intended for.</para>
        <section>
            <title>Coding standards</title>
            <para>The code is written in plain <literal>C</literal> using <literal>C99</literal>
                standards level together with the <acronym>GNU</acronym> extensions given by
                    <literal>#define _GNU_SOURCE</literal>. The code style is standard
                    <literal>K&amp;R</literal> with indentation of 4 and using Hungarian style for
                boolean comparisons. </para>
            <para>For robustness in string handling a set of custom string manipulation routines are
                used which are contained in the <filename>xstr.c</filename> module. This is
                especially important in the correct handling of <acronym>UTF8</acronym> encoded
                characters since in that case the old truth that one byte corresponds to one
                character breaks down. We take special care of not using the dangerous
                    <function>strnlen()</function> function for any kind of string manipulation.
                This is only used in the case we would like to copy a number of bytes from one are
                to another with a specific length.</para>
            <para>All functions (in general) return negative error codes and 0 for correct value.
                Working values are returned through pointer arguments.</para>
            <para>Camel case is used with occasional module separation naming using '_' character as
                appropriate.</para>
            <para><literal>const</literal> modifier is used when appropriate and full use of
                    <literal>C99</literal> declaration in blocks to better highlight declaration and
                usage of variables. When possible array indexes are always typed as
                    "<literal>size_t</literal>" except when old library routines makes this
                cumbersome.</para>
            <para>
                <note>
                    <para>The size for <literal>size_t</literal> is 8 bytes on 64 bit systems so it
                        might seem as a waste since the indexing principle could be achieved using
                            <literal>unsigned</literal> which is only 4 bytes. However, the compiler
                        in most cases can generate more efficient code with
                            <literal>size_t</literal> addresses than with unsigned. The small
                        drawback is that using <literal>size_t </literal>in datastructure will
                        result in slightly larger memory requirements.</para>
                </note>
            </para>
            <para>Stack variables are preferred up to a size to avoid nasty
                    <literal>malloc()</literal> errors when possible. At compile time the extra
                stack and malloc checks are enforced through additional command line arguments. When
                possible the dynamic array possibility in C99 are used instead of malloc/calloc
                calls.</para>
            <para><application>Doxygen</application>. Even though no doxygen generated documentation
                is included in the distribution all functions are commented using Doxyblock comments
                and a <application>Doxygen</application> configuration file is included in the
                source directory. <application>Doxygen</application> can be run without any
                significant warnings being generated. Doxygen comments for functions are only added
                in the "<filename>*.c</filename>" files and not complemented in the
                    "<filename>*.h</filename>" files.</para>
            <para>The overall code complexity is medium to complex (in cyclomatic sense). Many
                functions are in general low but a few reaches the complex level which makes the
                overall code medium-to-complex. However, a number of measurements are put in place
                to combat the complexity and full usage of compiler static analysis is made. The
                code is written primarily for clarity and not for optimization since for this type
                of application no trickery is needed. For an experienced Unix/GNU Linux developer
                the code should pose no problem since it only uses commonly used patterns for a
                    <literal>C</literal> program. </para>
            <para>The code is further structured so that no single source module in general is more
                than 2000 lines long (including comments and file pre-amble).</para>
            <para>Where possible pointer levels are restricted to two with the exception of pointer
                arrays supplied in function calls as out arguments. (typically exemplified by
                    <code>char *list[]</code> type of arrays)</para>
            <para>On a few occasions the following <literal>__attribute__ </literal>are used:</para>
            <para>
                <variablelist>
                    <varlistentry>
                        <term><emphasis role="bold"><literal>__attribute__
                                ((pure))</literal></emphasis></term>
                        <listitem>
                            <para>To indicate a side effect free function. Only used for funtion
                                prototypes</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><emphasis role="bold"><literal>__attribute__
                                    ((format(fmt,ifmt,ichk)))</literal></emphasis></term>
                        <listitem>
                            <para>Specifies static compiler check according to a format
                                string</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>A few compiler <code>#pragma</code> (both <application>gcc</application> and
                    <application>clang</application>) are also used to suppress warnings as
                necessary when there is a false positive. To indicate special
                    <productname>OSX</productname> consideration the test is made with the
                    <literal>__APPLE__</literal> define which is guaranteed to exist during
                compilation on <productname>OSX</productname>.</para>
        </section>
        <section>
            <title>Compilation</title>
            <para>The source has been instrumented to compile cleanly (no warnings) on both
                    "<command>clang</command>" (v3.2) or "<command>gcc</command>" (v4.7.x, 4.8.x).
                Some preprocessor conditionals is necessary to accomplish this since all warnings
                are enabled and flagged to give hard compile time errors. The code is further
                adapted to compile both on <acronym>GNU</acronym> Linux as well as
                    <productname>OSX</productname>. </para>
            <para>The code is compiled with the additional warnings and instrumentation flags as: </para>
            <para><literal>-pedantic -Wall -Werror -Wpointer-arith -Wstrict-prototypes -Wextra
                    -Wshadow, -Werror=format -Wformat=2 -fstack-protector
                    -D_FORTIFY_SOURCE=2</literal></para>
            <para>All of the above flags adds either one or more specific additional static tests or
                in te case of <literal>FORTIFY_SOURCE</literal> adds stack frame protection patterns
                to detect memory overwrites. For optimization "-O2" </para>
        </section> 
        <section>
            <title>Organization of the source code</title>
            <para>The source code follows a fairly standard layout with a separate source and
                documentation directories. Each directory has a short <filename>README</filename>
                file which documents the purpose of the directory.</para>
            <para>The code should be considered medium complex and consist of a number of
                programming and scripting languages. Table <xref linkend="table.source-stats"/>
                shows the break down for the source.</para>
            <para>All source files can be found in the <filename>src/</filename> directory. The
                daemon is divided into a number of source files together with a few supporting
                libraries contained in there own directories. An overview of the purpose of each
                source file is given in the table <xref linkend="table.source-files"/>.</para>
            <para>The statistics table was generated with the help of the <command>cloc</command>
                command and formatted for readability. All plain text files (such as mail templates)
                as well as the build system files are excluded from this statistics.</para>
            <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="table-src-stats.xml"/>
            </para>
        <para>
            <table xml:id="table.source-files">
                <title>Overview of source</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                    <colspec colname="c2" colnum="2" colwidth="3.33*"/>
                    <thead>
                        <row>
                            <entry>File</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row><entry><filename>connwatcher.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Watch for device connections</para><para>This is done by creating an <literal>inotify</literal> structure to watch the
                                            <filename>/dev</filename>directory for the apperance of
                                        a new <literal>ttyACM&lt;n> </literal>device.</para></entry></row>
                        <row><entry><filename>dbcmd.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Contains all commands and function that work with
                                        the database</para><para>The DB is built around a trivial sqlite3 database and only makes use of very rudimentary
                                            <acronym>SQL</acronym> to insert and extract data from
                                        the DB file.</para></entry></row>
                            <row>
                                <entry><filename>export.c</filename></entry>
                                <entry>
                                    <para><emphasis role="bold">Purpose:</emphasis> Routines to
                                        handle export to alternative formats like
                                            <acronym>GPX</acronym> and <acronym>KML</acronym></para>
                                </entry>
                            </row>
                        <row><entry><filename>futils.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Various file utility functions</para></entry></row>
                        <row><entry><filename>g7cmd.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Command dispatcher for user commands.</para><para>This contains the simple parser that reads the commands given by the user. To keep things
                                        simple the parsing is done with the help of the PCRE3
                                        library for regular expressions. In addition all the raw
                                        commands that is given to the device is defined here. The
                                        command for the device is entirely data driven which keeps
                                        the code short and understandable. </para>
                                    <para>This contain the thread that gets started by the
                                            <filename>socklistener.c</filename> main thread whenever
                                        a new command client connects.</para></entry></row>
                        <row><entry><filename>g7config.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Reads all values from the config file</para></entry></row>
                        <row><entry><filename>g7sendcmd.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis>Routines to do low/mid level communication with the
                                        device</para><para>This module contains the logic and routines that do the actual sending and receiving of
                                        commands from teh device with error checking.</para></entry></row>
                        <row><entry><filename>g7srvcmd.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis>Implements the logic for the internal server commands
                                        (server commands are those commands that starts with an
                                        initial "<literal>.</literal>").</para></entry></row>
                        <row><entry><filename>g7ctrl.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis>MAIN file. Initializes all structures and starts all
                                        threads</para><para>This is the main module which starts the daemon, reads the command line arguments, detaches
                                from the terminal and kicks of the main thread (in
                                <filename>worker.c</filename>) which listens for
                                incoming connections.</para></entry></row>
                            <row>
                                <entry><filename>geoloc.c</filename></entry>
                                <entry><para><emphasis role="bold">Purpose:</emphasis> Handle the
                                    translation of coordinates to approximate addresses through
                                    Google API</para></entry>
                            </row>                        
                            <row>
                                <entry><filename>gpsdist.c</filename></entry>
                                <entry><para><emphasis role="bold">Purpose:</emphasis> Functions to
                                    calculate the geodesic distance between lat/lon points</para></entry>
                            </row>
                        <row><entry><filename>lockfile.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Handle the lock file with the session pid</para></entry></row>
                        <row><entry><filename>logger.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Handles all logging to file</para></entry></row>
                        <row><entry><filename>mailutil.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Various convenience function to interface with the
                                        <acronym>SMTP</acronym> library in order to send mail using templates</para></entry></row>
                            <row>
                                <entry><filename>nicks.c</filename></entry>
                                <entry>
                                    <para><emphasis role="bold">Purpose:</emphasis> Handling of
                                        device nick names</para>
                                </entry>
                            </row>
                        <row><entry><filename>pcredmalloc.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Malloc routines used together with the PCRE3 library
                                        to keep track of the insanely stupid malloc schema in PCRE3
                                        which seems to be designed to give memory leaks.</para></entry></row>
                        <row><entry><filename>presets.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Handles reading and executing of presets</para></entry></row>
                        <row><entry><filename>rkey.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Handles replacing key templates in a file with
                                        designated values</para></entry></row>
                        <row><entry><filename>serial.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Handles low level serial communication with the
                                        device</para></entry></row>
                            <row>
                                <entry><filename>sighandling.c</filename></entry>
                                <entry><para><emphasis role="bold">Purpose:</emphasis> Signal handling including separate signal handling
                                        thread.</para>
                                    <para><emphasis role="bold">Note: </emphasis>The "mini-dump"
                                        logic and stack walking which is enabled when the code is
                                        configured with <literal>--enable-stacktrace</literal> is
                                        contained here.</para></entry>
                            </row>
                        <row><entry><filename>socklistener.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Contains the main socket server that listens to the
                            command and device socket and launches the appropriate
                            thread when a connection is made.</para></entry></row>                        
                        <row><entry><filename>tracker.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Is the main thread that gets created whenever a
                                        device connects.</para></entry></row>
                            <row>
                                <entry><filename>unicode_tbl.c</filename></entry>
                                <entry>
                                    <para><emphasis role="bold">Purpose:</emphasis> Routines to draw
                                        simple or complex tables using Unicode code point table
                                        characters</para>
                                </entry>
                            </row>
                        <row><entry><filename>utils.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> Various utility function used in all other
                                        places</para></entry></row>
                            <row>
                                <entry><filename>wreply.c</filename></entry>
                                <entry><emphasis role="bold">Purpose:</emphasis> Wrapper funcion to
                                    send back any reply string to the client.</entry>
                            </row>
                        <row><entry><filename>xstr.c</filename></entry><entry><para><emphasis role="bold">Purpose:</emphasis> A number of robust and memory safe versions of
                                        several usual string functions.</para><para>String handling is inherently unsafe (even the 'n' versions) and these routines makes it just
                                        a bit safer (together with some additional good-to-have
                                        string routines).</para>
                                    <para>This module also contain a set of UTF8 safe version of
                                        standard string routines with a prefix of
                                            "<literal>xmb_</literal>"</para></entry></row>
                        
                    </tbody>
                </tgroup>
            </table>
        </para>
            </section>
        <section>
            <title>Thread model</title>
            <para>To accommodate multiple clients and multiple connecting device standard POSIX
                threads are used. The threads used are:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Main thread that listens to the command and device ports (handled in
                                <filename>worker.c</filename>). When a new connection is detected it
                            is kicked of in its own thread as follows:</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>One thread for each connected clients to execute commands
                                        (handled in <filename>g7cmd.c</filename>)</para>
                                </listitem>
                                <listitem>
                                    <para>One thread for each connected device (handled in
                                            <filename>tracker.c</filename>)</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem>
                        <para>A signal handling thread where all signals are directed (handled in
                                <filename>g7ctrl.c</filename>)</para>
                    </listitem>
                    <listitem>
                        <para>A thread that watches for connected devices on the USB (handled in
                                <filename>connwatcher.c</filename>)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The main thread (and the application) is killed upon receiving the
                    <literal>SIGSTOP</literal> or <literal>SIGABRT</literal> signals as per
                standard.</para>
        </section>
        <section>
            <title>A note on command line parsing</title>
            <para>The parsing of command lines are handled through the use regular expression
                together with the <acronym>PCRE3</acronym> library. The motivation is that commands
                are fragmented and cannot really be considered a language justifying a full
                    <acronym>RDP</acronym>. To facilitate the specification of the syntax for the
                grammar a number of defines are used. They are all defined in
                    <filename>g7cmd.h</filename> and starts with an initial
                "<literal>_PR_</literal>". This makes it easier to understand and avoids tedious
                parenthesis matching errors. </para>
            <para>So for example to define a matching rule for the hypothetical command
                    "<literal>show line nnn filename</literal>" (which intends to show an arbitrary
                line from a file) we would write</para>
            <para>
                <screen>"show" _PR_S "line" _PR_S _PR_N _PR_S _PR_FNAME _PR_E</screen>
            </para>
            <para>
                <variablelist>
                    <varlistentry>
                        <term><literal>_PR_S</literal></term>
                        <listitem>
                            <para>One or more spaces</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>_PR_N</literal></term>
                        <listitem>
                            <para>One or more numeric characters</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>_PR_FNAME</literal></term>
                        <listitem>
                            <para>A filename</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>_PR_E</literal></term>
                        <listitem>
                            <para>The end of the expression</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>Compare this to the actual regular expression got by replacing the defines with
                the actual expression and the usefulness of this schema becomes obvious!</para>
            <para>Many more predefined useful regular expression fragments are defined in
                    <filename>util.h</filename>.</para>
        </section>
        <section>
            <title>Supporting libraries included</title>
            <para>In addition to the core source files above the library also makes use of the
                following support libraries. They are included as separate libraries since they
                could also be used free-standing from the daemon.</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>libsmtp</literal> - A basic library that wraps the
                                <acronym>SMTP</acronym> protocol into some higher level function
                            that makés it simple to create mails with attachment and alternate
                            content. One novelty I added to this library which I haven't seen
                            elsewhere is the possibility to simplify the inclusion of inline images
                            into mails. This library follows exactly the <acronym>SMTP</acronym>
                            <acronym>RFC</acronym> without any known deviations (in comparison with
                            many other public mail providers ...)</para>
                    </listitem>
                    <listitem>
                        <para><literal>libiniparser</literal> - A standard library written by parse
                            INI-files. This is included here since it is not available as a
                            pre-built library on all systems. The library is written by <emphasis
                                role="italic">N. Devillard</emphasis> and is available in the public
                            domain.</para>
                    </listitem>
                </itemizedlist>
            </para></section>
        <section xml:id="section.build-system">
            <title>The build system</title>
            <para>The system is a fairly standard autotools recursive make system. The
                    <filename>configure.ac</filename> file has a number of custom written macros to
                help setup the build for the Docbook5. The generated build files (for the
                distribution) will include a set of pre-built rendering of the documentations. This
                departs from the strict standard that a distribution should not include files that
                are generated. However, this is a practicality to avoid forcing end users to setup a
                complete Docbook5 environment just to get the documentation.</para>
            <para>The repository is strict in the sense that no generated files are checked in (this
                also reuqires some extra step to be done to recreate a build environment when the
                code is checked out directly from the repository.)</para>
            <para>The autotools setup is intended to be used with a modern style setup using
                    <filename>configure.ac</filename> and <command>autoreconf</command>.</para>
            <para>The source includes a utility directory with a few scripts that makes setting up a
                build system a bit simpler for developers wanting to get started with developing.
                These helper scripts are all located in the <filename>bldscripts</filename>
                directory (see more information in <xref xlink:href="#section.build-environment"/>).
                In addition to some helper script to setup a build environment a number of script
                are used as utilities during development and help with debugging.</para>
            <para>
                <note>
                    <para>The build scripts in the table below are not included in the release tar
                        ball but only available in te source repository since these are developer
                        tools and not needed for normal end user builds.</para>
                </note>
            </para>
            <table>
                <title>Utility builds cripts in the <filename>bldscripts</filename> directory </title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="0.4*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Name</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><filename>autoclean.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Cleans all generated
                                files and make the source as if just had been checked out from the
                                repository</entry>
                        </row>
                        <row>
                            <entry><filename>bootstrap.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Installs all complete
                                build environment in clean <emphasis role="bold">RPM based
                                    distribution</emphasis> such as
                                    <productname>OpenSuSE</productname>. This includes a complete
                                Docbook5 setup and installs all support libraries and does the
                                initial bootstrapping for autotools. This script is only meant to be
                                run once just after the source tree has been checked out from the
                                repository.</entry>
                        </row>
                        <row>
                            <entry><filename>bootstrap-deb.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Installs all complete
                                build environment in clean <emphasis role="bold">Debian based
                                    distribution</emphasis>. This includes a complete Docbook5 setup
                                and installs all support libraries and does the initial
                                bootstrapping for autotools. This script is only meant to be run
                                once just after the source tree has been checked out from the
                                repo.</entry>
                        </row>
                        <row>
                            <entry><filename>cntwc.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Count number of source
                                lines in the tree</entry>
                        </row>
                        <row>
                            <entry><filename>cov-bld.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis>Create a coverity augmented 
                                build that can subsequently be uploaded with <filename>cov-upload.sh</filename>
                            </entry>
                        </row>                                                
                        <row>
                            <entry><filename>cov-upload.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis>Upload a previous
                                augmented coverity build to the project account in Coverity Open
                                Source Service (See <filename>cov-bld.sh</filename>) </entry>
                        </row>
                        <row>
                            <entry><filename>gstackfcore.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> 
                                Print a full stack trace (for all threads) given a core dump file</entry>
                        </row>                        
                        <row>
                            <entry><filename>mkcl.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Creates a
                                    <filename>ChangeLog</filename> from the Subversion log using a
                                small custom XSL script (<filename>svn2cl.xsl</filename>)</entry>
                        </row>
                        <row>
                            <entry><filename>mkrelease.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Creates a new release
                                (reconfigures and runs <literal>make distcheck</literal>)</entry>
                        </row>
                        <row>
                            <entry><filename>rmtrsp.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Remove trailing spaces at end of line in all source files</entry>
                        </row>            
                        <row>
                            <entry><filename>setcorefile.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis>Specify kernel pattern for coure dump file</entry>
                        </row>                        
                        <row>
                            <entry><filename>src-stat.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Create the source
                                statisticsas included in the Technicla Appendix in the manual. The
                                statistics is based on <command>cloc</command> and then fomatted
                                into a nice <acronym>XML</acronym> table</entry>
                        </row>                                    
                        <row>
                            <entry><filename>stdbuild.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Configure and
                                build</entry>
                        </row>
                        <row>
                            <entry><filename>stdconfig.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Do a standard
                                configuration with silent rules enabled</entry>
                        </row>
                        <row>
                            <entry><filename>svnst</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Do a <literal>svn
                                    st</literal> but ignore all non added files</entry>
                        </row>
                        <row>
                            <entry><filename>svntag</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Tag a release</entry>
                        </row>
                        <row>
                            <entry><filename>tbc.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Total build and clean</entry>
                        </row>                        
                        <row>
                            <entry><filename>update.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Stop the current
                                running daemon in the system and install the newly built daemon (as
                                root). This script uses the systemd <command>systemctl</command>
                                method and hence assumes a recent system.</entry>
                        </row>
                        <row>
                            <entry><filename>init-update.sh</filename></entry>
                            <entry><emphasis role="bold">Purpose:</emphasis> Same as
                                    <filename>updated.sh</filename> but uses older
                                    "<filename>/etc/init.d</filename>" method.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
       </section>
        <section>
            <title>A note on build number</title>
            <para>In order to have a build number that truly is stepped for each build (and not just
                when a specific source file has been edited) the system makes use of a standard
                linker trick. The link processes defines two link time symbols (using
                    <acronym>GNU</acronym> linker <literal>--defsym</literal>) whose "fake"
                addresses are used in the source to get a build number. The build number is made
                persistent in the file <filename>build.txt</filename> which is stepped each time it
                is used. This makes for true build number sequence.</para>
            <para>However, this relies on the possibility to define new symbols at link time as
                supported by the <acronym>GNU</acronym> linker. On other system (such as <productname>OSX</productname>) where the linker do
                not support this option the build numbers are not used and will always be 0. </para>
            <para>
                <note>
                    <para>If someone could show how to accomplish the equivalent "trick" on
                            <productname>OSX</productname> we could fix this. Basically, what is
                        needed is the possibility always monotonically increase a build number at
                        link time.</para>
                </note>
            </para>
        </section>
        <section>
            <title>Generating a release</title>
            <para>A new release is generated by means of the "<command>make distcheck</command>"
                command to make sure we have a clean self-contained release. To also recreate the
                build from scratch and re-generate the <filename>Changelog</filename> the utility
                script "<filename>mkrelease.sh</filename>" should be used. The version number is as
                usual configured in <filename>autoconfig.ac</filename>. </para>
        </section>
    </section>
</appendix>
